{"version":3,"file":"escape.js","sourceRoot":"","sources":["../../src/escape.ts"],"names":[],"mappings":";;;AACA,uDAAyD;AACzD;;;;;;;;GAQG;AACI,MAAM,MAAM,GAAG,CACpB,CAAS,EACT,EACE,oBAAoB,GAAG,KAAK,MACsB,EAAE,EACtD,EAAE;IACF,wDAAwD;IACxD,4DAA4D;IAC5D,sDAAsD;IACtD,OAAO,oBAAoB;QACzB,CAAC,CAAC,IAAA,yCAAsB,EAAC,CAAC,EAAE,YAAY,EAAE,MAAM,CAAC;QACjD,CAAC,CAAC,IAAA,yCAAsB,EAAC,CAAC,EAAE,cAAc,EAAE,MAAM,CAAC,CAAA;AACvD,CAAC,CAAA;AAZY,QAAA,MAAM,UAYlB","sourcesContent":["import { MinimatchOptions } from './index.js'\nimport { StringPrototypeReplace } from 'node-primordials'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? StringPrototypeReplace(s, /[?*()[\\]]/g, '[$&]')\n    : StringPrototypeReplace(s, /[?*()[\\]\\\\]/g, '\\\\$&')\n}\n"]}